---
title: Опростяване на безконтекстни езици
author: Димо Йорданов
---

<!-- TOC -->
* [Премахване на безполезни променливи](#премахване-на-безполезни-променливи)
  * [Какво е жезполезна променлива](#какво-е-жезполезна-променлива)
  * [Алгоритъм за тяхното дезинтегриране](#алгоритъм-за-тяхното-дезинтегриране)
  * [Упътване](#упътване)
  * [Доказателство](#доказателство)
  * [Сложност](#сложност)
* [Алгоритъм за достижимост](#алгоритъм-за-достижимост)
  * [Упътване](#упътване-1)
  * [Доказателство](#доказателство-1)
* [Алгоритъм за безполезни правила](#алгоритъм-за-безполезни-правила)
* [Алгоритъм за премахване на епсилон правила](#алгоритъм-за-премахване-на-епсилон-правила)
  * [Упътване](#упътване-2)
  * [Доказателство](#доказателство-2)
* [Премахване на преименуващите правила](#премахване-на-преименуващите-правила)
  * [Упътване](#упътване-3)
* [Премахване на дългите правила](#премахване-на-дългите-правила)
<!-- TOC -->

# Премахване на безполезни променливи

## Какво е жезполезна променлива
Това е много просто променлива, която не участва в изода на която
и да е друга променлива, тоест няма как да я достъпъм

## Алгоритъм за тяхното дезинтегриране
> Нека е дадена безконтекстната граматика G и L(G) != {}.
> Същестува алгоритъм, кой то намира граматика G', за която 
> L(G)=L(G'), със свойството, че за всяка променлива A' в V'
> L(G',A')!={}

## Упътване

Цекта ние да намерим множеството Gen от променливи, които генерират думи
Това е още множеството Gen = {A във V, такова че езика на А не е празно множество}
Нека за да изградим това множество да построим редица от Gen

Gen[0] = {}
Gen[n+1] = {A е правило, такова че съществува дума съставена от букви и правилата от миналата
итерация на Gen, такава че има правило A->дума}
Спираме итерацията, когато достигнеме такова число на gen че множествтото се изравнява

## Доказателство
Трябва да докажем, че Gen=Gen[n]. Това ще направим като докажем че е изпълнена следната еквивалентност
А е в Gen, тогава и само тогава когато има думи от A в граматиката

## Сложност
Полиномиален

# Алгоритъм за достижимост
> Същестува алгоритъм, който по дадена безконтекстна граматика G=<V,E,R,S>
> намира G' = <V',E,R',S> такова че езиците им са равни, но всяка променлива в G' 
> е достицима от началната

## Упътване
Дефинираме си множеството 
Reach = {B е променлива, такава че @(S, дума1 B дума2, *), за някоя дума1 и дума2 смесица от правила и букви}

Нека да почнем строенето на Reach[i]

Reach[0] = {S}

Reach[i+1] = {В е правило, такова че съществува правило в Reach[i],
            така че същестува дума1 и дума2 и A->дума1 В дума2} обединено с миналата итерация

Алгоритъма спира когато Reach[i+1] = Reach[i]

## Доказателство
Трябва да докажем че за някое n, Reach[n] = Reach

# Алгоритъм за безполезни правила
Прилагаме Gen и след това Reach

# Алгоритъм за премахване на епсилон правила
> Съществува експоненциален алгоритъм, такъв че превръща всяка безконтекстна граматика G,
> в безконтекстна граматика G', Без правила от вида A->e и L(G') = L(G)

## Упътване
1. За да намерим правилата от този вид да построим E = {A е правило | @(A,e,*)}

Нека да построим множеството E[n]

E[0] = {}

E[n+1] = {В е правило такова че за някой набор от правила в E[n] има правило B->дума}
2. Строим множеството от правила R', които нямата е правила за всяко правило
А->X1....Xk, добавяме към R', които са всички правила от вида A->Y1....Yk
- Ако Xi не е от E, то Yi = Xi
- Ако Xi е от E, Yi=Xi, или Yi = e
- Не всички Y правила са е. В противен случай така бихме добавили А->e

## Доказателство
Да докажем следното E[n] = {A е правило и имаме дърво от А до е с по-малко или равно от n стъпки}
...

# Премахване на преименуващите правила
> Нека G е безконтекстна граматика без e-правила. Същестува полиномиален алгоритъм,
> такъв че превръша всяка безконтекстна граматика G в безконтекстна граматика G' без преименуващи
> правила такива че L(G') = L(G)

## Упътване
Първо намираме множеството Unit:={ всялка двойка от правила А и В такива че @(А,В,*)}

Нека да апроксимираме Unit[n]

Unit[0] = {(A,A) | A във V}

Unit[n+1] = Unit[n] обединено с {(A,B) | същ С такова че има правило
                                    A->C и (C,B) лежи в Unit[n]}

Спираме алгоритъма, когато Unit[n] = Unit[n+1]

Нека R0 = R\(VxV), правилата на новата граматика ще са
R' = {А е правило, а адума е комб от думи и правила | същестува В такова че (А,В) лежи в Unit и (B,дума) лежи в R0}

# Премахване на дългите правила

Просто букаме с променливи